<div class="control-panel">
  <div class="section">
    <input on:click="fire('init')" type="button" value="init" />
  </div>
  <div class="section">
    <input on:click="fire('next')" type="button" value="next" />
  </div>
  <div class="section">
    <button on:click='$set({ stopped: !$stopped})'>
      {#if $stopped}
      <div>
        <span>⌛</span>
      </div>
      {:else}
      <div style="transform:rotate(180deg);">
        <span>⌛</span>
      </div>
      {/if}
    </button>
  </div>
  <div class="section">
    <input class="min-width" on:click='toggleInterval($interval)' type="button" value="{`${$interval && $interval.name}`}" />
  </div>
  <div class="section">
    <input class="min-width" on:click='$set({ fieldtype: $fieldtype === "rectangular"
     ? "hexagonal"
     : "rectangular"
    })' type="button" value="{$fieldtype}" />
  </div>
  <!--
    TODO: make a color profile / state selection component
    FIXME: switcher with many different states, not only 2
  -->
  <!--
  <div class="section">
    <input on:click='$set({ statecolors: $statecolors.length === 3
      ? $stati[0]
      : $stati[1]
    })' type="button" value="{`${$statecolors ? $statecolors.length: 0} states`}" />
  </div>
  -->
  <div class="section">
    <input on:click='$set({ x: $x === 8 ? 16 : 8, y: $y === 8 ? 16 : 8 })' type="button" value="{`[${$x}x${$y}]`}" />
  </div>
  <div class="section">
    <input on:click='$set({ size: $size === 0.5 ? 0.25 : 0.5 })' type="button" value="size: {$size}" />
  </div>
</div>
<slot></slot>

<style>
  button,
  input[type="button"] {
    background-color: lightblue;
    border-radius: 6px;
    border-color: darkcyan;
  }

  /* style alternative state  */

  button:d {
    background-color: darkviolet;
  }

  .control-panel {
    display: flex;
    justify-items: center;
    justify-content: flex-start;
    background: seashell;
    padding: 4px;
    margin: 2px;
  }

  .section {
    border-left: 1px solid greenyellow;
  }

  .min-width {
    width: 100px;
  }
</style>

<script>
  import { increase, mapIterator as intervalIterator } from '../modules'

  let timerHandle
  const timer = function (t) {
    if (t.store) {
      const { stopped } = t.store.get()
      if (!stopped) {
        t.fire('next')
      }
    }
  }

  const intervals = intervalIterator([
    {
      _id: 0,
      ms: 1000,
      name: 'slow',
    },
    {
      _id: 1,
      ms: 500,
      name: 'normal',
    },
    {
      _id: 2,
      ms: 250,
      name: 'fast',
    },
    {
      _id: 3,
      ms: 100,
      name: 'superfast',
    }
  ])

  export default {
    oncreate() {
      const interval = intervals.next()
      this.store.set({ interval })
      const autostart = (t) => t.fire('init')
      setTimeout(autostart, 200, this)


      timerHandle = setInterval(timer, interval.ms, this)
    },
    ondestroy() {
      clearInterval(timerHandle)
      // FIXME: don't forget to reset intervals to initial state somehow as it is a generator..
    },
    methods: {
      toggleInterval(currentInterval) {
        const interval = intervals.next()
        this.store.set({ interval })
        clearInterval(timerHandle)
        timerHandle = setInterval(timer, interval.ms, this)
      }
    }
  }
</script>
